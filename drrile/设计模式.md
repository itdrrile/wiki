# 设计模式 - **可复用**

---

> - 松耦合设计思想
> - 面向对象设计原则
> - 重构技法改善设计
> - GOF核心设计模式

## 面向对象 - 抽象与底层结合

- 底层思维：向下，从微观理解对象构造
  - 语言构造
  - 编译转换
  - 内存模型
  - 运行时机制
  - 深入理解三大面向对象机制
    - 封装，隐藏内部实现
    - 继承，复用现有代码
    - 多态，改写对象行为
- **抽象**思维：向上，现实世界抽象为程序代码
  - 面向对象
  - 组件封装
  - 设计模式
  - 架构模式
- 解决复杂性的两种思维模型
  - 分解：分而治之，将复杂对象分解为多个简单问题，不能更好的解决变化，复用性很差
  - **抽象**：不能掌握全部的复杂对象，忽视一些非本质细节，去处理泛化和理想化的对象模型，能更好的解决变化，**复用性**很高
- 面向对象再认识
  - 宏观层面，面向对象的构建方式更能适应变化
  - 微观层面，面向对象方式更强调各个类的**责任**，变化导致新增的类型不会影响原来类型的实现，各司其职
  - 对象
    - 语言层面：封装了代码和数据
    - 规格层面：一系列可被使用的公共接口
    - 概念层面：拥有某种**责任**的抽象



---

## 面向对象设计原则

- DIP：**依赖倒置**，如何设计依赖关系
  - 高层模块不应该依赖于底层模块，底层模块应该依赖于高层模块
  - 抽象不应该依赖于实现，实现应该依赖于抽象
  - 稳定不应该依赖于变化，变化应该依赖于稳定
- OCP：**开闭原则**
  - 对**扩展**开放，对更改关闭，「*如何扩展?*」
  - 类模块应该是可扩展的，但不可修改
- SRP：**单一职责**，拒绝臃肿类
  - 一个类应该仅有一个引起它变化的原因
  - 变化的方向隐含着类的责任
- LSP：**Liskov替换原则**
  - 子类必须能够替换它们的基类（is a）
  - 继承表达类型抽象
- ISP：**接口隔离原则**
  - 接口应该小而完备
  - 接口方法设计要有封装性，仅开放那些必要的方法
- **组合优于继承使用**
  - 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”
  - 继承在某种程度上破坏了封装性「违背接口隔离原则，父类暴露了不必要的方法给子类」，子类父类耦合度高
  - 对象组合只要求被组合的对象具有良好定义的接口，耦合度低
- **封装变化点**
  - 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合
- **面向接口编程设计**
  - 不将变量类型声明为某个特定的具体类，而是声明为某个接口
  - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
  - 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案
  - 接口标准化，实现复用，实现分工合作



---

## 设计模式分类

### GOF-23 模式分类

- 按目的分类：
  - 创建型模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化给对象创建时具体类型实现引来的冲击
  - 结构型模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化给对象的结构带来的冲击
  - 行为型模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化给多个交互的对象带来的冲击
- 按范围分类：
  - 类模式：处理类与子类的静态关系
  - 对象模式：处理对象间的动态关系

### 从封装变化角度对模式分类

- 组件协作
  - [Template Method（模板方法）](#模板方法（Template Method）)
  - [Strategy（策略模式）](#策略模式（Strategy）)
  - [Observer/Event（观察者/事件模式）](#观察者/事件模式（Observer/Event）)
- 单一职责
  - Decorator（装饰）
  - Bridge（桥接）
- 对象创建
  - Factory Method（工厂）
  - Abstract Factory（抽象工厂）
  - Prototype（原型）
  - Builder（创建）
- 对象性能
  - Singleton（单例）
  - Flyweight
- 接口隔离
  - Facade（表观）
  - Proxy（代理）
  - Mediator
  - Adapter（适配器）
- 状态变化
  - Memento
  - State（状态机）
- 数据结构
  - Composite
  - Iterator（迭代器）
  - Chain of Resposibility（责任连）
- 行为变化
  - Command（命令）
  - Visitor（访问者）
- 领域问题
  - Interpreter



---

## 重构获得模式

- Refactoring to Patterns
- 使用设计模式的时机：寻找变化点，在变化点处应用设计模式
- 使用设计模式的误区：不应该一开始就使用设计模式，而是从重构过程中获得模式
- 重构方法：
  - 静态 -> 动态
  - 早绑定 -> 晚绑定
  - 继承 -> 组合
  - 编译时依赖 -> 运行时依赖
  - 紧耦合 -> 松耦合



---

## 组件协作模式

> **通过晚期绑定，实现框架与应用程序之间的松耦合**

### 模板方法（Template Method）

- 使用场景

  > 在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架于应用程序之间的关系）而无法和任务的整体结构同时实现。

  


- 模式定义 - 「父类定义**稳定算法**，并将流程中变化的步骤抽象化；子类重写变化的步骤，并复用稳定算法」

  > 定义一个操作中的算法的骨架（**稳定**），「**前提条件**」
  >
  > 而将一些步骤延迟（**变化**）到子类中。「**晚绑定**」
  >
  > 模板方法模式使得子类可以不改变（复用）一个算法的结构即可重定义（override）该算法的某些特定步骤
  >
  > - **若算法骨架不稳定，则模板方法模式不适用**
  > - 若算法骨架中不存在变化的步骤，则使用模板方法模式无意义

- 总结


  - 模板方式模式是一种非常基础性的设计模式，使用最简洁的机制（继承 + 抽象方法）为框架提供了**灵活的扩展点**，是代码复用方面的基本实现结构
  - 模板方法模式的晚绑定实现了框架对应用程序的**反向控制**调用
  - 模板方法模式中的抽象方法一般设置为**protected**方法

### 策略模式（Strategy）



### 观察者/事件模式（Observer/Event）