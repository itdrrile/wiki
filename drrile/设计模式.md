# 设计模式 - **可复用**

---

> - 松耦合设计思想
> - 面向对象设计原则
> - 重构技法改善设计
> - GOF核心设计模式

## 面向对象 - 抽象与底层结合

- 底层思维：向下，从微观理解对象构造
  - 语言构造
  - 编译转换
  - 内存模型
  - 运行时机制
  - 深入理解三大面向对象机制
    - 封装，隐藏内部实现
    - 继承，复用现有代码
    - 多态，改写对象行为
- **抽象**思维：向上，现实世界抽象为程序代码
  - 面向对象
  - 组件封装
  - 设计模式
  - 架构模式
- 解决复杂性的两种思维模型
  - 分解：分而治之，将复杂对象分解为多个简单问题，不能更好的解决变化，复用性很差
  - **抽象**：不能掌握全部的复杂对象，忽视一些非本质细节，去处理泛化和理想化的对象模型，能更好的解决变化，**复用性**很高
- 面向对象再认识
  - 宏观层面，面向对象的构建方式更能适应变化
  - 微观层面，面向对象方式更强调各个类的**责任**，变化导致新增的类型不会影响原来类型的实现，各司其职
  - 对象
    - 语言层面：封装了代码和数据
    - 规格层面：一系列可被使用的公共接口
    - 概念层面：拥有某种**责任**的抽象



---

## 面向对象设计原则

- DIP：**依赖倒置**，如何设计依赖关系
  - 高层模块不应该依赖于底层模块，底层模块应该依赖于高层模块
  - 抽象不应该依赖于实现，实现应该依赖于抽象
  - 稳定不应该依赖于变化，变化应该依赖于稳定
- OCP：**开闭原则**
  - 对**扩展**开放，对更改关闭，「*如何扩展?*」
  - 类模块应该是可扩展的，但不可修改
- SRP：**单一职责**，拒绝臃肿类
  - 一个类应该仅有一个引起它变化的原因
  - 变化的方向隐含着类的责任
- LSP：**Liskov替换原则**
  - 子类必须能够替换它们的基类（is a）
  - 继承表达类型抽象
- ISP：**接口隔离原则**
  - 接口应该小而完备
  - 接口方法设计要有封装性，仅开放那些必要的方法
- **组合优于继承使用**
  - 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”
  - 继承在某种程度上破坏了封装性「违背接口隔离原则，父类暴露了不必要的方法给子类」，子类父类耦合度高
  - 对象组合只要求被组合的对象具有良好定义的接口，耦合度低
- **封装变化点**
  - 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合
- **面向接口编程设计**
  - 不将变量类型声明为某个特定的具体类，而是声明为某个接口
  - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
  - 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案
  - 接口标准化，实现复用，实现分工合作



---

## 设计模式分类

### GOF-23 模式分类

- 按目的分类：
  - 创建型模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化给对象创建时具体类型实现引来的冲击
  - 结构型模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化给对象的结构带来的冲击
  - 行为型模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化给多个交互的对象带来的冲击
- 按范围分类：
  - 类模式：处理类与子类的静态关系
  - 对象模式：处理对象间的动态关系

### 从封装变化角度对模式分类

- 组件协作
  - [Template Method（模板方法）](#模板方法（Template Method）)
  - [Strategy（策略模式）](#策略模式（Strategy）)
  - [Observer/Event（观察者/事件模式）](#观察者/事件模式（Observer/Event）)
- 单一职责
  - [Decorator（装饰模式）](#装饰模式（Decorator）)
  - [Bridge（桥模式）](#桥模式（Bridge）)
- 对象创建
  - Factory Method（工厂方法）
  - Abstract Factory（抽象工厂）
  - Prototype（原型）
  - Builder（创建）
- 对象性能
  - Singleton（单例）
  - Flyweight
- 接口隔离
  - Facade（表观）
  - Proxy（代理）
  - Mediator
  - Adapter（适配器）
- 状态变化
  - Memento
  - State（状态机）
- 数据结构
  - Composite
  - Iterator（迭代器）
  - Chain of Resposibility（责任连）
- 行为变化
  - Command（命令）
  - Visitor（访问者）
- 领域问题
  - Interpreter



---

## 重构获得模式

- Refactoring to Patterns
- 使用设计模式的时机：寻找变化点，在变化点处应用设计模式
- 使用设计模式的误区：不应该一开始就使用设计模式，而是从重构过程中获得模式
- 重构方法：
  - 静态 -> 动态
  - 早绑定 -> 晚绑定
  - 继承 -> 组合
  - 编译时依赖 -> 运行时依赖
  - 紧耦合 -> 松耦合



---

## 组件协作模式

> **通过晚期绑定，实现框架与应用程序之间的松耦合**



### 模板方法（Template Method）

- 使用场景

  > 在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架于应用程序之间的关系）而无法和任务的整体结构同时实现。

  


- 模式定义  - 「父类定义**稳定算法**，并将流程中变化的步骤抽象化；子类重写变化的步骤，并复用稳定算法」

  > 定义一个操作中的算法的骨架（**稳定**），「**前提条件**」
  >
  > 而将一些步骤延迟（**变化**）到子类中。「**晚绑定**」
  >
  > 模板方法模式使得子类可以不改变（复用）一个算法的结构即可重定义（override）该算法的某些特定步骤
  >
  > - **若算法骨架不稳定，则模板方法模式不适用**
  > - 若算法骨架中不存在变化的步骤，则使用模板方法模式无意义

- 总结


  - 模板方式模式是一种非常基础性的设计模式，使用最简洁的机制（继承 + 抽象方法）为框架提供了**灵活的扩展点**，是代码复用方面的基本实现结构
  - 模板方法模式的晚绑定实现了框架对应用程序的**反向控制**调用
  - 模板方法模式中的抽象方法一般设置为**protected**方法

  

### 策略模式（Strategy）

- 使用场景

  > 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。
  >
  > 策略模式在**运行时**根据需要，透明地更改对象的算法，将算法与对象本身接偶。
  >
  > - 对于面向过程思维，经常性使用if条件判断使用不同的算法

- 模式定义

  > 定义**一系列算法**，把它们一个个封装起来，并且使它们可互相替换（**变化**）；「算法是变化的，可扩展的」
  >
  > 策略模式使得算法可独立于使用它的**客户程序**（**稳定**）而变化（扩展，子类化）。「客户程序是稳定的，引用了算法的抽象」

- 总结

  - 策略模式中子类为组件提供了一系列可重用的算法，从而可以使得类型在**运行时**方便地根据需要在各个算法之间进行切换
  - 策略模式提供了条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要策略模式
  - 如果策略模式对象没有实例变量，那么各个上下文可以共享同一个策略对象，从而节省对象开销



### 观察者/事件模式（Observer/Event）

- 使用场景

  > 在软件构建过程中，需要为某些对象建立一种“**通知依赖关系**”———一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。
  >
  > 如果这样的依赖关系过于紧密，将使软件不能很好的抵御变化。

- 模式定义

  > 定义对象间的一种一对多（变化）的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

- 总结

  - 使用面向对象的抽象，观察者模式使得可以独立地改变目标与观察者，从而使二者之间的依赖关系达到松耦合
  - 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播
  - 观察者自定决定是否需要订阅通知，目标对象对此一无所知
  - 观察者模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分



---

## 单一职责

> 在软件组件设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，**子类急剧膨胀**，同时充斥着重复代码。



### 装饰模式（Decorator）

- 使用场景

  > 过度地使用继承来扩展对象的功能，
  >
  > 继承为类型引入的静态特质，使得继承这种扩展方式缺乏灵活性，
  >
  > 随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀
  >
  > - **组合优于继承使用**

- 模式定义

  > 动态（组合）地给一个对象增加一些额外的职责。
  >
  > 就增加功能而言，装饰模式比生成子类（继承）更为灵活（消除重复代码、减少子类个数）
  
- 总结

  - 通过采用组合而非继承的手法，装饰模式实现了在**运行时**动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”
  - 装饰类在接口上表现为is a组件类的继承关系，即装饰类继承了组件类所具有的接口。但在实现上又表现为has a组件类的组合关系，即装饰类又使用了另外一个组件类
  - 装饰模式的目的并非解决“多子类衍生的多继承”问题，而在于解决“主体类在多个方向上的扩展功能”



### 桥模式（Bridge）

- 使用场景

  > 由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至**多个维度的变化**。

- 模式定义

  > 将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立的变化。

- 总结

  - 桥模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化（即子类化它们）
  - 桥模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差
  - 桥模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用桥模式的扩展模式



---

## 对象创建

