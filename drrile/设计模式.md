# 设计模式 - **可复用**

---

> - 松耦合设计思想
> - 面向对象设计原则
> - 重构技法改善设计
> - GOF核心设计模式

## 面向对象 - 抽象与底层结合

- 底层思维：向下，从微观理解对象构造
  - 语言构造
  - 编译转换
  - 内存模型
  - 运行时机制
  - 深入理解三大面向对象机制
    - 封装，隐藏内部实现
    - 继承，复用现有代码
    - 多态，改写对象行为
- **抽象**思维：向上，现实世界抽象为程序代码
  - 面向对象
  - 组件封装
  - 设计模式
  - 架构模式
- 解决复杂性的两种思维模型
  - 分解：分而治之，将复杂对象分解为多个简单问题，不能更好的解决变化，复用性很差
  - **抽象**：不能掌握全部的复杂对象，忽视一些非本质细节，去处理泛化和理想化的对象模型，能更好的解决变化，**复用性**很高
- 面向对象再认识
  - 宏观层面，面向对象的构建方式更能适应变化
  - 微观层面，面向对象方式更强调各个类的**责任**，变化导致新增的类型不会影响原来类型的实现，各司其职
  - 对象
    - 语言层面：封装了代码和数据
    - 规格层面：一系列可被使用的公共接口
    - 概念层面：拥有某种**责任**的抽象



---

## 面向对象设计原则

- DIP：**依赖倒置**，如何设计依赖关系
  - 高层模块不应该依赖于底层模块，底层模块应该依赖于高层模块
  - 抽象不应该依赖于实现，实现应该依赖于抽象
  - 稳定不应该依赖于变化，变化应该依赖于稳定
- OCP：**开闭原则**
  - 对**扩展**开放，对更改关闭，「*如何扩展?*」
  - 类模块应该是可扩展的，但不可修改
- SRP：**单一职责**，拒绝臃肿类
  - 一个类应该仅有一个引起它变化的原因
  - 变化的方向隐含着类的责任
- LSP：**Liskov替换原则**
  - 子类必须能够替换它们的基类（is a）
  - 继承表达类型抽象
- ISP：**接口隔离原则**
  - 接口应该小而完备
  - 接口方法设计要有封装性，仅开放那些必要的方法
- **组合优于继承使用**
  - 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”
  - 继承在某种程度上破坏了封装性「违背接口隔离原则，父类暴露了不必要的方法给子类」，子类父类耦合度高
  - 对象组合只要求被组合的对象具有良好定义的接口，耦合度低
- **封装变化点**
  - 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合
- **面向接口编程设计**
  - 不将变量类型声明为某个特定的具体类，而是声明为某个接口
  - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口
  - 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案
  - 接口标准化，实现复用，实现分工合作



---

## 设计模式分类

### GOF-23 模式分类

- 按目的分类：
  - 创建型模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化给对象创建时具体类型实现引来的冲击
  - 结构型模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化给对象的结构带来的冲击
  - 行为型模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化给多个交互的对象带来的冲击
- 按范围分类：
  - 类模式：处理类与子类的静态关系
  - 对象模式：处理对象间的动态关系

### 从封装变化角度对模式分类

- 组件协作
  - [Template Method（模板方法）](#模板方法（Template Method）)
  - [Strategy（策略模式）](#策略模式（Strategy）)
  - [Observer/Event（观察者/事件模式）](#观察者/事件模式（Observer/Event）)
- 单一职责
  - [Decorator（装饰模式）](#装饰模式（Decorator）)
  - [Bridge（桥模式）](#桥模式（Bridge）)
- 对象创建
  - [Factory Method（工厂方法）](#工厂方法模式（Factory Method）)
  - [Abstract Factory（抽象工厂）](#抽象工厂模式（Abstract Factory）)
  - [Prototype（原型）](#原型模式（Prototype）)
  - [Builder（创建）](#构建器模式（builder）)
- 对象性能
  - [Singleton（单例）](#单例模式（Singleton）)
  - [Flyweight（享元）](#享元模式（Flyweight）)
- 接口隔离
  - Facade（门面）
  - Proxy（代理）
  - Mediator
  - Adapter（适配器）
- 状态变化
  - Memento
  - State（状态机）
- 数据结构
  - Composite
  - Iterator（迭代器）
  - Chain of Resposibility（责任连）
- 行为变化
  - Command（命令）
  - Visitor（访问者）
- 领域问题
  - Interpreter



---

## 重构获得模式

- Refactoring to Patterns
- 使用设计模式的时机：寻找变化点，在变化点处应用设计模式
- 使用设计模式的误区：不应该一开始就使用设计模式，而是从重构过程中获得模式
- 重构方法：
  - 静态 -> 动态
  - 早绑定 -> 晚绑定
  - 继承 -> 组合
  - 编译时依赖 -> 运行时依赖
  - 紧耦合 -> 松耦合



---

## 组件协作模式

> **通过晚期绑定，实现框架与应用程序之间的松耦合**



### 模板方法（Template Method）

- 使用场景

  > 在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架于应用程序之间的关系）而无法和任务的整体结构同时实现。

  


- 模式定义  - 「父类定义**稳定算法**，并将流程中变化的步骤抽象化；子类重写变化的步骤，并复用稳定算法」

  > 定义一个操作中的算法的骨架（**稳定**），「**前提条件**」
  >
  > 而将一些步骤延迟（**变化**）到子类中。「**晚绑定**」
  >
  > 模板方法模式使得子类可以不改变（复用）一个算法的结构即可重定义（override）该算法的某些特定步骤
  >
  > - **若算法骨架不稳定，则模板方法模式不适用**
  > - 若算法骨架中不存在变化的步骤，则使用模板方法模式无意义

- 总结


  - 模板方式模式是一种非常基础性的设计模式，使用最简洁的机制（继承 + 抽象方法）为框架提供了**灵活的扩展点**，是代码复用方面的基本实现结构
  - 模板方法模式的晚绑定实现了框架对应用程序的**反向控制**调用
  - 模板方法模式中的抽象方法一般设置为**protected**方法

  

### 策略模式（Strategy）

- 使用场景

  > 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。
  >
  > 策略模式在**运行时**根据需要，透明地更改对象的算法，将算法与对象本身接偶。
  >
  > - 对于面向过程思维，经常性使用if条件判断使用不同的算法

- 模式定义

  > 定义**一系列算法**，把它们一个个封装起来，并且使它们可互相替换（**变化**）；「算法是变化的，可扩展的」
  >
  > 策略模式使得算法可独立于使用它的**客户程序**（**稳定**）而变化（扩展，子类化）。「客户程序是稳定的，引用了算法的抽象」

- 总结

  - 策略模式中子类为组件提供了一系列可重用的算法，从而可以使得类型在**运行时**方便地根据需要在各个算法之间进行切换
  - 策略模式提供了条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要策略模式
  - 如果策略模式对象没有实例变量，那么各个上下文可以共享同一个策略对象，从而节省对象开销



### 观察者/事件模式（Observer/Event）

- 使用场景

  > 在软件构建过程中，需要为某些对象建立一种“**通知依赖关系**”———一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。
  >
  > 如果这样的依赖关系过于紧密，将使软件不能很好的抵御变化。

- 模式定义

  > 定义对象间的一种一对多（变化）的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

- 总结

  - 使用面向对象的抽象，观察者模式使得可以独立地改变目标与观察者，从而使二者之间的依赖关系达到松耦合
  - 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播
  - 观察者自定决定是否需要订阅通知，目标对象对此一无所知
  - 观察者模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分



---

## 单一职责

> 在软件组件设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，**子类急剧膨胀**，同时充斥着重复代码。



### 装饰模式（Decorator）

- 使用场景

  > 过度地使用继承来扩展对象的功能，
  >
  > 继承为类型引入的静态特质，使得继承这种扩展方式缺乏灵活性，
  >
  > 随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀
  >
  > - **组合优于继承使用**

- 模式定义

  > 动态（组合）地给一个对象增加一些额外的职责。
  >
  > 就增加功能而言，装饰模式比生成子类（继承）更为灵活（消除重复代码、减少子类个数）
  
- 总结

  - 通过采用组合而非继承的手法，装饰模式实现了在**运行时**动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”
  - 装饰类在接口上表现为is a组件类的继承关系，即装饰类继承了组件类所具有的接口。但在实现上又表现为has a组件类的组合关系，即装饰类又使用了另外一个组件类
  - 装饰模式的目的并非解决“多子类衍生的多继承”问题，而在于解决“主体类在多个方向上的扩展功能”



### 桥模式（Bridge）

- 使用场景

  > 由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至**多个维度的变化**。

- 模式定义

  > 将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立的变化。

- 总结

  - 桥模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化（即子类化它们）
  - 桥模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差
  - 桥模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用桥模式的扩展模式



---

## 对象创建

> 通过“对象创建”模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。
>
> 对象创建是接口抽象之后的第一步工作。



### 工厂方法模式（Factory Method）

- 使用场景

  > 在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化

- 模式定义

  > 定义一个用于创建对象的接口，让子类决定实例化哪一个类。
  >
  > 工厂方法使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。

- 总结

  - 工厂方法模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系（new）会导致软件的脆弱
  - 工厂方法模式通过面向对象的手法，将所要创建的具体对象工作延迟到了子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系
  - 工厂模式解决“单个对象”的需求变化，缺点在于要求创建方法/参数相同

  

### 抽象工厂模式（Abstract Factory）

- 使用场景

  > 在软件系统中，经常面临着“**一系列相互依赖**的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。

- 模式定义

  > 提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。

- 总结

  - 如果没有应对“多系列多对象构建”的需求变化，则没必要使用抽象工厂模式，这时候使用简单工厂就可以
  - “系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列对象之间不能相互依赖
  - 抽象工厂模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动



### 原型模式（Prototype）

- 使用场景

  > 在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。

- 模式定义

  > 使用原型实例指定创建对象的种类，然后通过拷贝（深克隆）这些原型来创建新的对象

- 总结

  - 原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有稳定的接口
  - 原型模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象———所需工作仅仅是注册一些新类的对象（即原型），然后在任何需求的地发进行克隆
  - 原型模式中的克隆方法可以利用某些框架中的序列化来实现深拷贝



###  构建器模式（builder）

- 使用场景

  > 在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。

- 模式定义

  > 将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）

- 总结

  - 构建器模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化
  - 构建器模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动
  - 在构建器模式中，要注意不同语言中构造器内调用虚函数的差别



---

## 对象性能

> 面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。
>
> 对于通常情况来说，面向对象的成本大都可以忽略不计。
>
> 某些情况下，面向对象所带来的成本必须谨慎处理



### 单例模式（Singleton）

- 使用场景

  > 在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能保证它们逻辑的正确性、以及良好的效率

- 模式定义

  > 保证一个类仅有一个实例，并提供一个该实例的全局访问点。

- 总结

  - 单例模式中的实例构造器可以设置为protected以允许子类派生
  - 单例模式一般不要支持拷贝构造函数和clone接口，因为这有可能导致多个对象实例
  - 多线程环境下的安全单例模式：双检查锁+volatile



### 享元模式（Flyweight）

- 使用场景

  > 在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价

- 模式定义

  > 运用**共享**技术有效地支持**大量**细粒度的对象

- 总结

  - 享元模式采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力
  - 享元模式主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题



---

## 接口隔离

> 在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。
>
> 采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。

